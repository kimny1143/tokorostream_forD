tokoroui_st02_local.py:
------------------------------
import streamlit as st
import audio_pr_stream as ap
import os
import shutil

def ensure_directory_exists(directory):
    try:
        if not os.path.exists(directory):
            os.makedirs(directory)
            print(f"Created directory: {directory}")  # 確認用の出力
        else:
            print(f"Directory already exists: {directory}")  # 既に存在する場合の出力
    except Exception as e:
        print(f"Failed to create directory {directory}: {e}")  # エラー発生時の出力


def rename_and_move_files(source_dir, target_base_dir):
    valid_extensions = ['.wav', '.mp3', '.pdf']
    files = [f for f in os.listdir(source_dir) if os.path.isfile(os.path.join(source_dir, f)) and any(f.endswith(ext) for ext in valid_extensions)]
    
    for file_name in files:
        base_name, ext = os.path.splitext(file_name)
        new_base_name = base_name # ファイル名の変更がない場合は元のファイル名を使用
        if base_name.count('X') < 2 and base_name.startswith('0'):
            # '0'で始まるが'X'が1つ以下のファイル名を改名
            new_base_name = base_name.lstrip('0') + 'X'
            new_file_name = new_base_name + ext
        elif base_name.count('X') == 1:
            # 既に適切な形式のファイル名はそのまま使用
            new_file_name = file_name
        else:
            # 命名規則に合わないファイルやXが2回以上あるファイルはスキップ
            continue
        
        song_number = ''.join([char for char in new_base_name if char.isdigit() or char == 'X'])
        target_dir = os.path.join(target_base_dir, song_number)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)
            print(f"Created directory: {target_dir}")

        shutil.move(os.path.join(source_dir, file_name), os.path.join(target_dir, new_file_name))
        print(f"Moved and renamed {file_name} to {new_file_name} in {target_dir}")

def main():
    st.title("Tokoroten Audio and Document Processing")

    input_dir = st.text_input("入力フォルダのパスを入力してください")
    output_dir = st.text_input("出力フォルダのパスを入力してください")
    target_base_dir = st.text_input("目的のベースフォルダのパスを入力してください")

    sources = []
    if st.checkbox('vocals'):
        sources.append('vocals')
    if st.checkbox('drums'):
        sources.append('drums')
    if st.checkbox('bass'):
        sources.append('bass')
    if st.checkbox('other'):
        sources.append('other')

    if st.button("Run") and input_dir and output_dir and target_base_dir:
        ensure_directory_exists(output_dir)
        try:
            for file_name in os.listdir(input_dir):
                if file_name.endswith(('.wav', '.mp3')):
                    file_path = os.path.join(input_dir, file_name)
                    audio_data, sample_rate = ap.load_audio_file(file_path)
                    ap.process_audio_file(file_path, sources, 'umxhq', 'cpu', output_dir)
                
            rename_and_move_files(input_dir, target_base_dir)
            rename_and_move_files(output_dir, target_base_dir)
            st.success("すべてのファイルの処理と移動が完了しました！")
        except Exception as e:
            st.error(f"処理中にエラーが発生しました: {e}")

if __name__ == '__main__':
    main()

------------------------------
audio_pr_stream.py:
------------------------------
import os
import sys
import logging
import torch
import torch.hub
import soundfile as sf
import numpy as np
import openunmix
import librosa
import audioread
import tempfile
import scipy.signal
from madmom.features.beats import RNNBeatProcessor, DBNBeatTrackingProcessor


logging.basicConfig(filename='app.log', filemode='w', format='%(name)s - %(levelname)s - %(message)s', level=logging.DEBUG)

def convert_mp3_to_wav(input_mp3, output_wav):
    try:
        with audioread.audio_open(input_mp3) as source:
            data = []
            for buffer in source.read_data():
                data.append(np.frombuffer(buffer, dtype='<i2'))  # Adjust dtype based on source format
            audio_data = np.concatenate(data)
            audio_data = audio_data.reshape(-1, source.channels)
            sf.write(output_wav, audio_data, source.samplerate, format='WAV', subtype='PCM_16')
        logging.info(f"Converted MP3 to WAV: {input_mp3} -> {output_wav}")
    except Exception as e:
        logging.error(f"Error during MP3 to WAV conversion: {e}")
        raise

def resample_audio(input_file, target_sr=44100):
    data, original_sr = sf.read(input_file, always_2d=True)
    if original_sr != target_sr:
        if data.shape[1] == 1:
            resampled_data = librosa.resample(data[:, 0], orig_sr=original_sr, target_sr=target_sr)
        else:
            resampled_data_stereo = [librosa.resample(data[:, ch], orig_sr=original_sr, target_sr=target_sr) for ch in range(data.shape[1])]
            resampled_data = np.stack(resampled_data_stereo, axis=-1)
        return resampled_data, target_sr
    else:
        return data, original_sr
    

def load_audio_file(file_path):
    try:
        logging.info(f"Loading audio file {file_path}")
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension == ".mp3":
            temp_wav = tempfile.mktemp(suffix='.wav')
            convert_mp3_to_wav(file_path, temp_wav)
            audio_data, sample_rate = resample_audio(temp_wav)
            os.remove(temp_wav)
        else:
            audio_data, sample_rate = resample_audio(file_path)
        if audio_data.ndim == 1:
            audio_data = np.stack([audio_data, audio_data], axis=1)
        return audio_data, sample_rate
    except Exception as e:
        logging.error(f"Error loading audio file: {e}")
        raise

def process_audio_file(file_path, sources, model, device, output_dir):
    try:
        audio_data, sample_rate = load_audio_file(file_path)
        if audio_data is None:
            raise Exception(f"Error loading audio file {file_path}")
        
        # 楽曲番号を取得し、必要に応じて改名
        base_name = os.path.splitext(os.path.basename(file_path))[0]
        ext = os.path.splitext(file_path)[1]

        # 先頭の「0」を取り除く
        if base_name.startswith('0'):
            base_name = base_name.lstrip('0')

        # 「X」がまだなければ、楽曲番号の直後に追加
        if 'X' not in base_name:
            base_name += 'X'


        audio_data = audio_data.T  # transpose the audio data
        audio_tensor = torch.from_numpy(audio_data).float().to(device)  # convert to Float here
        audio_tensor = audio_tensor[None, ...]  # add batch dimension
        separator = torch.hub.load('sigsep/open-unmix-pytorch', model, device=device)
        estimates = separator(audio_tensor)  # no need to convert to Double here

        for i, source_name in enumerate(['vocals', 'drums', 'bass', 'other']):
            if source_name in sources:
                source_audio = estimates[0, i, :].detach().cpu().numpy()  # convert to numpy
                output_filename = f"{base_name}_{source_name}{ext}"
                output_path = os.path.join(output_dir, output_filename)
                sf.write(output_path, source_audio.T, sample_rate)
    except Exception as e:
        error_message = f"Error processing file {file_path}: {e}"
        logging.error(error_message)
        raise Exception(error_message)  # Report the error through Streamlit GUI

------------------------------
tokoroui_st02_web.py:
------------------------------
import streamlit as st
import audio_pr_stream as ap
import os
import tempfile
import zipfile
import io

def process_uploaded_files(uploaded_files, output_dir):
    for uploaded_file in uploaded_files:
        file_path = os.path.join(output_dir, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        ap.process_audio_file(file_path, sources, 'umxhq', 'cpu', output_dir)

def create_directory_structure(output_dir, zip_buffer):
    for root, dirs, files in os.walk(output_dir):
        for file in files:
            file_path = os.path.join(root, file)
            relative_path = os.path.relpath(file_path, output_dir)
            zip_buffer.write(file_path, arcname=relative_path)

def main():
    st.title("Tokoroten Audio Processing")

    sources = []
    if st.checkbox('vocals'):
        sources.append('vocals')
    if st.checkbox('drums'):
        sources.append('drums')
    if st.checkbox('bass'):
        sources.append('bass')
    if st.checkbox('other'):
        sources.append('other')

    uploaded_files = st.file_uploader("Choose files to process", accept_multiple_files=True)
    
    if st.button("Process") and uploaded_files:
        with tempfile.TemporaryDirectory() as temp_dir:
            output_dir = os.path.join(temp_dir, "output")
            os.makedirs(output_dir, exist_ok=True)

            try:
                process_uploaded_files(uploaded_files, output_dir)

                zip_buffer = io.BytesIO()
                with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
                    create_directory_structure(output_dir, zip_file)

                zip_buffer.seek(0)
                st.download_button(
                    label="Download ZIP",
                    data=zip_buffer,
                    file_name="processed_files.zip",
                    mime="application/zip"
                )
                st.success("Processing completed successfully!")
            except Exception as e:
                st.error(f"An error occurred during processing: {e}")

if __name__ == '__main__':
    main()
------------------------------
